def process_data(df, target_column_prefix, new_column_name, date_columns):
    """
    Filters and processes data for weekly cumulative reports (Sections 4-11).
    Calculates dynamic base, weekly, and final cumulative counts.
    """
    
    # 1. Identify Forecast and Actual Completion Date Columns
    col_fcst = next((col for col in df.columns if target_column_prefix.replace('A', 'F') in col), None)
    col_actual = next((col for col in df.columns if target_column_prefix.replace('F', 'A') in col), None)
    
    if not col_fcst or not col_actual:
        print(f"Warning: Columns for prefix '{target_column_prefix}' not found. Skipping section.")
        empty_data = {'Task name': [f'{new_column_name} (FCST)', f'{new_column_name} (Actual)', f'{new_column_name} (FCST Cumulative)', f'{new_column_name} (Actual Cumulative)']}
        empty_df = pd.DataFrame(empty_data)
        for wk in date_columns: empty_df[wk] = 0
        return empty_df

    # -------------------------------------------------------------------------
    # --- Dynamic Base and Weekly Count Helper Functions ---
    # -------------------------------------------------------------------------

    # Get the ISO week number for the start of the first week (Wk 40)
    # Assuming Week 40 starts on a fixed date (e.g., usually the Monday closest to Sep 30/Oct 1)
    # Since we only care if a date is BEFORE Wk 40, we only need the number 40.
    START_WEEK_NUM = int(date_columns[0].split(' ')[1]) # Should be 40
    
    target_weeks_map = {int(wk.split(' ')[1]): wk for wk in date_columns}

    def calculate_cumulative_base(df_data, date_col):
        """Calculates the count of completed items before the start of the first reporting week (Wk 40)."""
        df_dates = pd.to_datetime(df_data[date_col], errors='coerce').dropna()
        if df_dates.empty:
            return 0
        
        temp_dates = df_dates.dt.normalize()
        
        # Filter for dates whose ISO week number is less than the start week (40)
        # Note: This is simplified. For year-end/year-start reports, you'd need to check the year too.
        # Assuming all relevant dates fall in the same calendar year.
        base_count = temp_dates[temp_dates.dt.isocalendar().week < START_WEEK_NUM].count()
        return base_count

    def calculate_weekly_counts(df_data, date_col):
        """Helper to calculate weekly counts (Wk 40-52) from a date column."""
        df_dates = pd.to_datetime(df_data[date_col], errors='coerce').dropna()
        if df_dates.empty:
            return {wk: 0 for wk in date_columns}
        
        temp_dates = df_dates.dt.normalize()
        df_weeks = temp_dates.dt.isocalendar().week.astype(int)
        
        weekly_counts_series = df_weeks.value_counts().sort_index()
        counts = {wk: 0 for wk in date_columns}
        
        # Populate the counts only for the target weeks (Wk 40-52)
        for iso_week, count in weekly_counts_series.items():
            if iso_week in target_weeks_map:
                counts[target_weeks_map[iso_week]] = count
        return counts

    # -------------------------------------------------------------------------
    # --- Execute Calculations ---
    # -------------------------------------------------------------------------

    # 1. Calculate Dynamic Base Values
    PREVIOUS_MONTH_BASE_FCST = calculate_cumulative_base(df, col_fcst)
    PREVIOUS_MONTH_BASE_ACTUAL = calculate_cumulative_base(df, col_actual)
    print(f"[{new_column_name}] Calculated Base: FCST={PREVIOUS_MONTH_BASE_FCST}, Actual={PREVIOUS_MONTH_BASE_ACTUAL}")
    
    # 2. Calculate Weekly Counts
    fcst_counts = calculate_weekly_counts(df, col_fcst)
    actual_counts = calculate_weekly_counts(df, col_actual)
    
    # 3. Calculate Cumulative Values
    fcst_cumulative = [PREVIOUS_MONTH_BASE_FCST]
    actual_cumulative = [PREVIOUS_MONTH_BASE_ACTUAL]
    
    # Calculate cumulative values by adding weekly counts to the running total
    for i, wk in enumerate(date_columns):
        current_fcst = fcst_counts[wk]
        current_actual = actual_counts[wk]
        
        fcst_cumulative.append(fcst_cumulative[-1] + current_fcst)
        actual_cumulative.append(actual_cumulative[-1] + current_actual)
            
    # Remove the initial base value used for calculation setup
    fcst_cumulative.pop(0)
    actual_cumulative.pop(0)
    
    # 4. Construct the final DataFrame
    data = {
        'Task name': [
            f'{new_column_name} (FCST)', 
            f'{new_column_name} (Actual)', 
            f'{new_column_name} (FCST Cumulative)', 
            f'{new_column_name} (Actual Cumulative)'
        ]
    }
    
    # Add the weekly data
    for i, wk in enumerate(date_columns):
        data[wk] = [
            fcst_counts[wk], 
            actual_counts[wk], 
            fcst_cumulative[i], 
            actual_cumulative[i]
        ]
        
    return pd.DataFrame(data)


def calculate_weekly_counts(df_data, date_col):
    """Helper to calculate weekly counts (Wk 40-52) from a date column with robust parsing."""
    
    # --- FIX 1: Robust Date Parsing ---
    # Use 'mixed' inference to handle varied date formats and coerce true non-dates to NaT
    df_dates = pd.to_datetime(df_data[date_col], errors='coerce', infer_datetime_format=True).dropna()
    # ----------------------------------
    
    if df_dates.empty:
        return {wk: 0 for wk in date_columns}
    
    # Use dt.normalize() to remove time component and prevent boundary errors
    temp_dates = df_dates.dt.normalize()
    df_weeks = temp_dates.dt.isocalendar().week.astype(int)
    
    # -------------------------------------------------------------------------
    # --- Mapping and Aggregation (Logic remains the same) ---
    # -------------------------------------------------------------------------
    
    target_weeks_map = {int(wk.split(' ')[1]): wk for wk in date_columns}
    
    weekly_counts_series = df_weeks.value_counts().sort_index()
    counts = {wk: 0 for wk in date_columns}
    
    # Populate the counts only for the target weeks (Wk 40-52)
    for iso_week, count in weekly_counts_series.items():
        if iso_week in target_weeks_map:
            counts[target_weeks_map[iso_week]] = count
    return counts

