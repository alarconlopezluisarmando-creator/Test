def process_data(df, target_column_prefix, new_column_name, date_columns):
    """
    Filters and processes data for weekly cumulative reports (Sections 4-11).
    Calculates dynamic base, weekly, and final cumulative counts.
    """
    
    # 1. Identify Forecast and Actual Completion Date Columns
    # Example: If prefix is 'V:(F 1115)', col_fcst should match a column like 'V:(F 1115) ...'
    # .replace('A', 'F') and .replace('F', 'A') correctly toggles between Forecast (F) and Actual (A) prefixes.
    fcst_prefix = target_column_prefix.replace('A', 'F') 
    actual_prefix = target_column_prefix.replace('F', 'A')

    # Look for the full column name that starts with the prefix.
    col_fcst = next((col for col in df.columns if col.startswith(fcst_prefix)), None)
    col_actual = next((col for col in df.columns if col.startswith(actual_prefix)), None)
    
    # -------------------------------------------------------------------------
    # --- CRITICAL ERROR CHECK (PREVENTS 'NoneType' ERROR) ---
    if col_fcst is None or col_actual is None:
        print(f"Warning: Missing required columns for '{new_column_name}'. FCST prefix sought: '{fcst_prefix}', Actual prefix sought: '{actual_prefix}'. Skipping section.")
        empty_data = {'Task name': [f'{new_column_name} (FCST)', f'{new_column_name} (Actual)', f'{new_column_name} (FCST Cumulative)', f'{new_column_name} (Actual Cumulative)']}
        empty_df = pd.DataFrame(empty_data)
        for wk in date_columns: empty_df[wk] = 0
        return empty_df
    # -------------------------------------------------------------------------

    # Get the ISO week number for the start of the first week (Wk 40)
    START_WEEK_NUM = int(date_columns[0].split(' ')[1]) # Should be 40
    target_weeks_map = {int(wk.split(' ')[1]): wk for wk in date_columns}

    # --- Helper Functions (using the fixed date parsing from the last response) ---
    
    def calculate_cumulative_base(df_data, date_col):
        """Calculates the count of completed items before the start of the first reporting week (Wk 40)."""
        # Ensure date_col is NOT None before subscripting
        if date_col is None: return 0 

        # Use robust date parsing
        df_dates = pd.to_datetime(df_data[date_col], errors='coerce', infer_datetime_format=True).dropna()
        if df_dates.empty: return 0
        
        temp_dates = df_dates.dt.normalize()
        base_count = temp_dates[temp_dates.dt.isocalendar().week < START_WEEK_NUM].count()
        return base_count

    def calculate_weekly_counts(df_data, date_col):
        """Helper to calculate weekly counts (Wk 40-52) from a date column."""
        # Ensure date_col is NOT None before subscripting
        if date_col is None: return {wk: 0 for wk in date_columns}
        
        # Use robust date parsing
        df_dates = pd.to_datetime(df_data[date_col], errors='coerce', infer_datetime_format=True).dropna()
        if df_dates.empty: return {wk: 0 for wk in date_columns}
        
        temp_dates = df_dates.dt.normalize()
        df_weeks = temp_dates.dt.isocalendar().week.astype(int)
        
        weekly_counts_series = df_weeks.value_counts().sort_index()
        counts = {wk: 0 for wk in date_columns}
        
        for iso_week, count in weekly_counts_series.items():
            if iso_week in target_weeks_map:
                counts[target_weeks_map[iso_week]] = count
        return counts

    # -------------------------------------------------------------------------
    # --- Execute Calculations ---
    # Since we passed the initial check, col_fcst and col_actual are guaranteed to be strings (column names).

    # 1. Calculate Dynamic Base Values
    PREVIOUS_MONTH_BASE_FCST = calculate_cumulative_base(df, col_fcst)
    PREVIOUS_MONTH_BASE_ACTUAL = calculate_cumulative_base(df, col_actual)
    # ... (Rest of the calculation logic is the same and uses col_fcst/col_actual safely) ...
    
    # 2. Calculate Weekly Counts
    fcst_counts = calculate_weekly_counts(df, col_fcst)
    actual_counts = calculate_weekly_counts(df, col_actual)
    
    # 3. Calculate Cumulative Values
    fcst_cumulative = [PREVIOUS_MONTH_BASE_FCST]
    actual_cumulative = [PREVIOUS_MONTH_BASE_ACTUAL]
    
    # Calculate cumulative values by adding weekly counts to the running total
    for i, wk in enumerate(date_columns):
        current_fcst = fcst_counts[wk]
        current_actual = actual_counts[wk]
        
        fcst_cumulative.append(fcst_cumulative[-1] + current_fcst)
        actual_cumulative.append(actual_cumulative[-1] + current_actual)
            
    # Remove the initial base value used for calculation setup
    fcst_cumulative.pop(0)
    actual_cumulative.pop(0)
    
    # 4. Construct the final DataFrame
    data = {
        'Task name': [
            f'{new_column_name} (FCST)', 
            f'{new_column_name} (Actual)', 
            f'{new_column_name} (FCST Cumulative)', 
            f'{new_column_name} (Actual Cumulative)'
        ]
    }
    
    # Add the weekly data
    for i, wk in enumerate(date_columns):
        data[wk] = [
            fcst_counts[wk], 
            actual_counts[wk], 
            fcst_cumulative[i], 
            actual_cumulative[i]
        ]
        
    return pd.DataFrame(data)
